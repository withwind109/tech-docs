# Dart 异步编程

异步编程用于执行耗时操作，如网络请求、数据库操作或复杂的计算，以避免阻塞主线程并保持应用的响应性。

## Dart 的事件循环

Dart 的事件循环是一个内置的机制，它负责管理事件（如 I/O、定时器、微任务等）和异步操作的执行顺序。事件循环与异步编程紧密相关，因为它允许 Dart 程序执行非阻塞操作，同时继续处理其他任务。

事件循环的工作原理如下：

1. **微任务队列（Microtask queue）**：这是一个先进先出的队列，用于调度微任务（microtask）。微任务通常是由 `Future` 完成时的回调或者是通过 `scheduleMicrotask` 函数添加的任务。微任务队列的优先级高于事件队列，事件循环会首先执行所有微任务直到队列为空。

2. **事件队列（Event queue）**：事件队列也是一个先进先出的队列，用于调度宏任务（macrotask），如 I/O 事件、定时器回调等。只有当微任务队列为空时，事件循环才会从事件队列中取出任务执行。

事件循环的一个周期通常包括以下步骤：

-   执行当前代码。
-   执行微任务队列中的所有微任务。
-   如果有必要，渲染 UI。
-   检查事件队列，如果有事件，则处理事件并执行相应的回调。
-   重复上述步骤。

在 Dart 的异步编程中，当你使用 `async`、`await`、`Future`、`Stream` 等构造时，你实际上是在与事件循环交互。例如，当你 `await` 一个 `Future`，你告诉事件循环在 `Future` 完成时恢复执行你的代码。这样，你的代码不会阻塞，而是允许事件循环处理其他事件或微任务，直到 `Future` 完成。

事件循环使得 Dart 能够执行异步操作，同时保持单线程的简单性，并避免了多线程编程中常见的竞态条件和死锁问题。

在 JavaScript 中，事件循环是异步编程的核心概念，它类似于 Dart 的事件循环。JavaScript 的事件循环包括任务队列（task queue）和微任务队列（microtask queue），它们负责调度和执行异步代码。

在 Flutter 中，调度任务和延时任务是异步编程的一部分，它们允许你在未来的某个时间点执行代码，而不会阻塞主线程。

## 具体使用

### 调度任务（Scheduled Tasks）

调度任务通常是指那些你想要在未来某个确定时间点执行的任务。在 Flutter 中，你可以使用 `Timer` 类来调度这样的任务。`Timer` 可以创建单次的或重复的任务。例如，你可以使用 `Timer` 来在 5 秒后执行一个函数，或者每隔 1 秒执行一次。

```dart
import 'dart:async';

// 单次延时任务
Timer(Duration(seconds: 5), () {
  // 这个代码块会在 5 秒后执行
});

// 重复执行的任务
Timer.periodic(Duration(seconds: 1), (Timer t) {
  // 这个代码块会每隔 1 秒执行一次
});
```

### 延时任务（Delayed Tasks）

延时任务是指在当前任务完成后，但在未来某个时间点之前不立即执行的任务。在 Dart（因此也在 Flutter）中，你可以使用 `Future.delayed` 来创建一个延时任务。这个方法允许你指定一个延迟时间，然后执行一个回调函数。

```dart
Future.delayed(Duration(seconds: 3), () {
  // 这个代码块会在 3 秒后执行
});
```

这种机制在 Flutter 中非常有用，比如在显示一个加载指示器一段时间后再显示内容，或者在用户操作后延迟执行某些逻辑。

调度任务和延时任务都是非阻塞的，它们允许 Flutter 应用保持响应性，同时等待某些操作完成或时间到达。这些任务在 Dart 的事件循环中被安排执行，不会干扰 UI 的渲染和用户的交互。

### Future 详解

在 Flutter（以及 Dart）中，`Future` 是一个核心类，用于表示一个潜在的值，或者一个可能在未来某个时间点才会完成的计算。`Future` 可以完成并返回一个值，也可以因为发生错误而无法完成。它们是异步编程的基础，允许你编写非阻塞代码，这对于保持 UI 的流畅性至关重要。

#### 基本使用

当你有一个可能需要一些时间来计算的值时，你可以使用 `Future`。例如，一个网络请求就是一个典型的异步操作，它可能需要几秒钟的时间来获取响应。

在 Dart 中，你可以通过多种方式创建一个`Future`。以下是一些常见的方法：

1. 使用`Future`构造函数

```dart
Future<String> myFuture = Future(() {
  // 执行一些异步操作
  return 'Hello from the future!';
});
```

在这个例子中，我们创建了一个新的`Future`，它将在未来的某个时间点完成，并返回一个字符串。

##### 使用`Future.value`创建已经完成的`Future`

```dart
Future<String> myFuture = Future.value('Immediate result');
```

这将创建一个已经完成的`Future`，其结果是提供的值。

2. 使用`Future.delayed`创建延迟的`Future`

```dart
Future<String> myFuture = Future.delayed(Duration(seconds: 2), () {
  // 这个函数会在2秒后被调用
  return 'Delayed result';
});
```

这个`Future`会在指定的延迟时间后完成。

3. 使用`Completer`

如果你需要在未来的某个时间点手动完成一个`Future`，你可以使用`Completer`。

```dart
Completer<String> completer = Completer<String>();
Future<String> myFuture = completer.future;

// 在某个时间点，你可以完成这个Future
completer.complete('Completed result');
```

你可以在任何时候调用`completer.complete()`来完成这个`Future`，或者使用`completer.completeError()`来抛出一个错误。

这些是创建`Future`的一些基本方法。在实际的应用程序中，你可能会根据具体的异步任务来选择最合适的方法。

#### 使用 `async` 和 `await`

为了更简洁和直观地处理 `Future`，Dart 提供了 `async` 和 `await` 关键字。使用这些关键字，你可以以接近同步代码的方式编写异步代码。

下面是使用 `async` 和 `await` 的相同 `Future` 示例：

```dart
Future<String> fetchUserData() async {
  // 模拟一个网络请求，延迟2秒后返回一个字符串
  await Future.delayed(Duration(seconds: 2));
  return 'Fetched User Data';
}

void main() async {
  print('Fetching user data...');
  try {
    String data = await fetchUserData();
    // 当Future完成时，这里的代码会被执行
    print(data); // 打印 'Fetched User Data'
  } catch (error) {
    // 如果在等待Future时发生错误，这里的代码会被执行
    print(error);
  }

  print('Here, other code can run while waiting for the user data to be fetched.');
}
```

在这个例子中，`fetchUserData` 函数被标记为 `async`，这意味着它会返回一个 `Future`。函数体内的 `await` 关键字会暂停执行直到 `Future` 完成。如果 `Future` 成功完成，它的结果可以被赋值给一个变量。如果 `Future` 失败，错误可以被捕获并处理。

#### 错误处理

`Future` 还提供了错误处理的机制。如果在 `Future` 执行过程中发生错误，你可以使用 `catchError` 方法来捕获并处理这些错误。在使用 `async` 和 `await` 时，你可以使用 `try-catch` 块来捕获异常。

#### 链式调用

`Future` 还支持链式调用，允许你组合多个异步操作。使用 `then` 方法，你可以在一个 `Future` 完成后执行另一个操作，并且可以继续这样链式调用下去。

```dart
Future<String> fetchUserData() {
  // 模拟一个网络请求，延迟2秒后返回一个字符串
  return Future.delayed(Duration(seconds: 2), () => 'Fetched User Data');
}

Future<void> main() {
  fetchUserData()
    .then((data) {
      print(data); // 打印 'Fetched User Data'
      return 'Processed User Data';
    })
    .then((processedData) {
      print(processedData); // 打印 'Processed User Data'
    })
    .catchError((error) {
      print(error);
    });

  print('Other code can run while waiting for the user data.');
}
```

在这个链式调用的例子中，第一个 `then` 方法处理 `fetchUserData` 返回的 `Future`。当这个 `Future` 完成时，它会打印出获取到的数据，并返回一个新的字符串 `'Processed User Data'`。这个返回的字符串会被包装成一个新的 `Future`，然后传递给下一个 `then` 方法。在第二个 `then` 方法中，我们打印出处理后的数据。如果在任何一个 `Future` 执行过程中发生错误，`catchError` 方法会捕获这个错误，并允许我们处理它。

#### 并行执行 Futures

如果你有多个独立的 `Future` 需要执行，并且你希望它们并行执行，你可以使用 `Future.wait` 方法。这个方法接受一个 `Future` 列表，并返回一个单一的 `Future`，该 `Future` 将在所有传入的 `Future` 完成后完成。

```dart
Future<String> fetchUserData() {
  return Future.delayed(Duration(seconds: 2), () => 'User Data');
}

Future<String> fetchOrderData() {
  return Future.delayed(Duration(seconds: 3), () => 'Order Data');
}

Future<void> main() async {
  print('Fetching user and order data...');
  try {
    List<String> results = await Future.wait([fetchUserData(), fetchOrderData()]);
    print(results[0]); // 打印 'User Data'
    print(results[1]); // 打印 'Order Data'
  } catch (error) {
    print(error);
  }
  print('Fetched all data.');
}
```

在这个例子中，`fetchUserData` 和 `fetchOrderData` 函数分别返回两个 `Future`，它们分别在 2 秒和 3 秒后完成。`Future.wait` 被用来等待这两个 `Future` 都完成。当它们都完成时，它们的结果会作为一个列表返回，我们可以通过索引来访问每个结果。

#### 总结

`Future` 是 Dart 中处理异步编程的基础，它允许你执行耗时操作，如 I/O、网络请求等，而不会阻塞主线程。通过使用 `then`、`catchError`、`async`、`await` 和 `Future.wait` 等机制，你可以有效地控制异步代码的执行流程，并处理可能出现的错误。

### lsolate

在 Flutter 中，`Isolate`是一个独立的执行线程，它不共享内存，并运行在自己的事件循环中。每个`Isolate`有它自己的堆内存，这意味着 Flutter 的主`Isolate`（也就是 UI 线程）不会被耗时的计算任务阻塞，从而保证了用户界面的流畅性。

`Isolate`通常用于执行 CPU 密集型任务或长时间运行的计算，比如解析大量数据、进行复杂的数学计算等。这样可以避免这些操作阻塞 UI 线程，导致应用界面卡顿。

下面是一个简单的例子，展示了如何在 Flutter 中创建和使用`Isolate`：

```dart
import 'dart:isolate';

// 一个耗时的计算函数
int intensiveCalculation(int count) {
  int total = 0;
  for (int i = 0; i < count; i++) {
    total += i;
  }
  return total;
}

// 用于在Isolate中执行的函数
void calculationIsolate(SendPort sendPort) {
  // 接收消息的端口
  final port = ReceivePort();
  // 将接收端口的发送端口发送回主Isolate
  sendPort.send(port.sendPort);

  // 监听来自主Isolate的消息
  port.listen((message) {
    // 获取数据和回复的SendPort
    final data = message[0];
    final replyTo = message[1] as SendPort;

    // 执行耗时的计算
    final result = intensiveCalculation(data);

    // 将结果发送回主Isolate
    replyTo.send(result);
  });
}

Future<void> main() async {
  // 创建接收端口以接收来自新Isolate的消息
  final receivePort = ReceivePort();
  // 创建新的Isolate
  await Isolate.spawn(calculationIsolate, receivePort.sendPort);

  // 获取新Isolate发送的SendPort
  final sendPort = await receivePort.first as SendPort;

  // 创建另一个接收端口以接收计算结果
  final response = ReceivePort();
  // 发送数据和接收结果的SendPort给新Isolate
  sendPort.send([1000000, response.sendPort]);

  // 获取结果
  final result = await response.first;
  print('计算结果: $result');

  // ... 这里可以继续执行其他任务，比如更新UI
}
```

在这个例子中，我们创建了一个新的`Isolate`来执行`intensiveCalculation`函数，这是一个模拟的 CPU 密集型任务。我们通过`ReceivePort`和`SendPort`来在主`Isolate`和新创建的`Isolate`之间传递消息和结果。这样，即使是耗时的计算，也不会影响到 Flutter 的 UI 线程。

在使用 Dart 的 `Isolate` 时，存在同步问题，因为 `Isolate` 是运行在不同执行线程上的，它们之间的内存是隔离的。这意味着你不能简单地通过共享内存来同步状态，而是必须通过消息传递来进行通信。

当你从主 `Isolate`（通常是 UI 线程）发送消息到另一个 `Isolate`，并期望得到一个结果时，这个过程是异步的。你不能立即得到结果，而是需要等待另一个 `Isolate` 完成计算并发送回消息。这通常是通过 `Future` 或者 `Stream` 来处理的，这些都是异步编程的一部分。

在上面的例子中，主 `Isolate` 发送消息给工作 `Isolate` 并等待结果，这是通过 `await response.first;` 实现的。这个调用会暂停代码的执行，直到 `response` `ReceivePort` 接收到来自工作 `Isolate` 的消息。在这个等待期间，主 `Isolate` 可以继续处理其他事件，比如用户输入或者动画，这样就不会阻塞 UI。

如果你需要在主 `Isolate` 中同步地获取工作 `Isolate` 的结果，这是不可能的，因为 Dart 的异步机制不允许在等待异步操作的同时阻塞执行线程。你必须使用异步模式（如 `async` 和 `await`）来处理这种情况。

总的来说，`Isolate` 的使用确实引入了同步问题，但 Dart 提供了异步编程工具来帮助你管理这些问题，确保即使在进行耗时的后台计算时，应用程序的主线程也能保持响应。

### Stream 异步事件序列对象

在 Dart 中，`Stream` 是一种用于接收异步事件的序列。你可以监听一个`Stream`，并且当事件（比如数据）到来时，你的监听器会被调用。

### 单订阅流（Single-subscription Stream）

单订阅流是一种只能有一个监听器的`Stream`。一旦有监听器开始监听，其他监听器就不能再添加了。

```dart
// 创建一个单订阅流
var singleSubscriptionStream = Stream.fromIterable([1, 2, 3]);

// 监听流
singleSubscriptionStream.listen((item) {
  print(item); // 打印 1, 2, 3
});

// 如果尝试添加第二个监听器，将会抛出异常。
// singleSubscriptionStream.listen((item) { ... }); // 错误
```

### 广播流（Broadcast Stream）

广播流允许多个监听器同时监听。这意味着多个消费者可以接收到相同的数据事件。

```dart
// 创建一个广播流
var broadcastStream = Stream.fromIterable([1, 2, 3]).asBroadcastStream();

// 第一个监听器
broadcastStream.listen((item) {
  print('Listener 1: $item');
});

// 第二个监听器
broadcastStream.listen((item) {
  print('Listener 2: $item');
});

// 两个监听器都可以接收到数据事件。
```

### Stream Transformer（流转换器）

`StreamTransformer` 是一个可以接收`Stream`上的数据，对其进行处理，并产生新数据的组件。

```dart
// 创建一个流转换器，将整数翻倍
var transformer = StreamTransformer<int, int>.fromHandlers(
  handleData: (int data, EventSink<int> sink) {
    sink.add(data * 2); // 输出翻倍的值
  },
);

// 创建一个单订阅流
var stream = Stream.fromIterable([1, 2, 3]);

// 应用流转换器
var transformedStream = stream.transform(transformer);

// 监听转换后的流
transformedStream.listen((item) {
  print(item); // 打印 2, 4, 6
});
```

在这个例子中，我们创建了一个`StreamTransformer`，它接收流中的每个整数，将其翻倍，然后通过`EventSink`将翻倍后的整数发送到新的流中。然后我们监听这个转换后的流，并打印出翻倍后的值。
