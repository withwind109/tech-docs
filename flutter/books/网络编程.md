# Dart 网络请求相关知识整理

## TCP 服务端和客户端

在 Dart 中，可以使用`dart:io`库来实现 TCP 服务端和客户端。以下是一个简单的示例：

**TCP 服务端**:

```dart
import 'dart:io';
import 'dart:convert';

Future<void> main() async {
  // 创建一个TCP服务器，监听本地主机的4040端口
  var server = await ServerSocket.bind(InternetAddress.loopbackIPv4, 4040);
  print('Listening on ${server.address.address}:${server.port}');

  await for (var client in server) {
    // 处理客户端连接
    client.listen((data) {
      // 接收客户端数据
      var message = utf8.decode(data);
      print('Message from client: $message');
      // 向客户端发送响应
      client.write('Echo: $message');
    },
    // 当客户端连接关闭时调用
    onDone: () {
      print('Client left');
      client.close();
    });
  }
}
```

**TCP 客户端**:

```dart
import 'dart:io';
import 'dart:convert';

Future<void> main() async {
  // 连接到TCP服务器
  var socket = await Socket.connect('localhost', 4040);
  print('Connected to: ${socket.remoteAddress.address}:${socket.remotePort}');

  // 发送数据到服务器
  var message = 'Hello, World!';
  print('Sending: $message');
  socket.write(message);

  // 接收来自服务器的响应
  await socket.listen((data) {
    var response = utf8.decode(data);
    print('Response from server: $response');
    socket.destroy();
  }).asFuture();

  // 关闭连接
  await socket.close();
}
```

在这个例子中，服务端创建了一个`ServerSocket`来监听特定的端口，并接受客户端的连接。每当有新的客户端连接时，服务端都会接收数据并发送回声响应。

客户端通过`Socket.connect`连接到服务端，并发送一条消息。然后，它等待并接收服务端的响应，最后关闭连接。

请确保在运行这些示例之前，你的环境中已经安装了 Dart SDK，并且你的防火墙设置允许相应的网络通信。

## UDP 的服务端和客户端

在 Dart 中，使用`dart:io`库可以实现 UDP 服务端和客户端。以下是一个简单的示例：

**UDP 服务端**:

```dart
import 'dart:io';
import 'dart:convert';

Future<void> main() async {
  // 创建一个UDP套接字
  var socket = await RawDatagramSocket.bind(InternetAddress.anyIPv4, 4040);
  print('UDP Echo server listening on ${socket.address.address}:${socket.port}');

  // 监听接收到的数据
  socket.listen((RawSocketEvent e) {
    Datagram? datagram = socket.receive();
    if (datagram == null) return;

    var message = utf8.decode(datagram.data);
    print('Received message: $message from ${datagram.address.address}:${datagram.port}');

    // 发送响应到客户端
    socket.send(datagram.data, datagram.address, datagram.port);
  });
}
```

**UDP 客户端**:

```dart
import 'dart:io';
import 'dart:convert';

Future<void> main() async {
  // 创建一个UDP套接字
  var socket = await RawDatagramSocket.bind(InternetAddress.anyIPv4, 0);
  print('UDP client bound to ${socket.address.address}:${socket.port}');

  // 发送消息到UDP服务端
  var message = 'Hello, UDP Server!';
  List<int> data = utf8.encode(message);
  var serverAddress = InternetAddress.loopbackIPv4;
  socket.send(data, serverAddress, 4040);
  print('Sent message: $message to ${serverAddress.address}:4040');

  // 监听来自服务端的响应
  socket.listen((RawSocketEvent e) {
    if (e == RawSocketEvent.read) {
      Datagram? datagram = socket.receive();
      if (datagram == null) return;

      var response = utf8.decode(datagram.data);
      print('Received response: $response from ${datagram.address.address}:${datagram.port}');
      socket.close();
    }
  });
}
```

在这个例子中，服务端创建了一个`RawDatagramSocket`来监听特定的端口，并接受客户端的数据报文。每当收到数据报文时，服务端都会打印消息并将相同的数据报文发送回客户端。

客户端也创建了一个`RawDatagramSocket`，并向服务端发送了一条消息。然后，它等待并接收服务端的响应，最后关闭套接字。

请确保在运行这些示例之前，你的环境中已经安装了 Dart SDK，并且你的防火墙设置允许相应的网络通信。

### HTTP 请求实现

#### 原理

Dart 中的网络请求通常是基于 `HttpClient` 类实现的，它是 Dart 的内置类，提供了发送 HTTP 请求的基础功能。第三方库通常是在 `HttpClient` 的基础上封装，提供更高级的功能和更简洁的 API。

#### 第三方库

1. **http**

    - **优点**: 官方支持，简单易用，适合轻量级的网络请求。
    - **缺点**: 功能相对基础，不支持一些高级特性如拦截器、全局配置等。

2. **Dio**

    - **优点**: 功能强大，支持拦截器、FormData、请求取消、文件下载、超时等。
    - **缺点**: 相对复杂，学习成本高于 `http` 库。

3. **Chopper**

    - **优点**: 使用注解生成请求代码，易于维护，支持拦截器和转换器。
    - **缺点**: 需要额外的代码生成步骤，学习曲线较陡峭。

4. **http_interceptor**

    - **优点**: 可以与 `http` 库结合使用，提供拦截器功能。
    - **缺点**: 功能相对有限，主要提供拦截器。

5. **retrofit.dart**

    - **优点**: 类似于 Chopper，使用注解，自动生成接口代码。
    - **缺点**: 需要代码生成，配置较为复杂。

6. **http2**
    - **优点**: 支持 HTTP/2 协议。
    - **缺点**: 使用场景有限，不是所有服务器都支持 HTTP/2。

#### 代码示例

-   **http** 示例:

```dart
import 'package:http/http.dart' as http;

void main() async {
  var url = Uri.parse('https://example.com/api/data');
  var response = await http.get(url);

  if (response.statusCode == 200) {
    print('Response data: ${response.body}');
  } else {
    print('Request failed with status: ${response.statusCode}.');
  }
}
```

-   **Dio** 示例:

```dart
import 'package:dio/dio.dart';

void main() async {
  var dio = Dio();
  var response = await dio.get('https://example.com/api/data');
  if (response.statusCode == 200) {
    print('Response data: ${response.data}');
  } else {
    print('Request failed with status: ${response.statusCode}.');
  }
}
```

-   **Chopper** 示例 (需要先进行代码生成):

```dart
import 'package:chopper/chopper.dart';

part 'main.chopper.dart';

@ChopperApi(baseUrl: '/api')
abstract class MyService extends ChopperService {
  @Get(path: 'data')
  Future<Response> getData();

  static MyService create() {
    final client = ChopperClient(
      services: [_$MyService()],
      converter: JsonConverter(),
    );
    return _$MyService(client);
  }
}

void main() async {
  final myService = MyService.create();
  final response = await myService.getData();

  if (response.isSuccessful) {
    print('Response data: ${response.body}');
  } else {
    print('Request failed with status: ${response.statusCode}.');
  }
}
```

#### 总结

选择哪个库取决于你的项目需求和个人偏好。如果你需要快速简单的解决方案，`http` 库可能是最好的选择。如果你的项目需要复杂的请求处理、错误处理、拦截器等高级功能，Dio 或 Chopper 可能更适合。对于需要注解和自动生成代码的方式，可以考虑 Chopper 或 retrofit.dart。如果你需要使用 HTTP/2 的特性，那么 `http2` 库将是必要的。
