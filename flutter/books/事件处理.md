在 Flutter 中，手势处理是通过一系列的手势检测器小部件来实现的。这些小部件可以检测各种类型的用户输入，如点击、双击、长按、拖动、滑动等。下面是一些常用的手势检测器及其用法的简单介绍和代码示例：

1. `GestureDetector`：这是一个通用的手势检测器，可以处理各种类型的手势。
2. `TapGestureRecognizer`：用于处理点击事件。
3. `LongPressGestureRecognizer`：用于处理长按事件。
4. `DragGestureRecognizer`：用于处理拖动事件，如水平或垂直拖动。
5. `ScaleGestureRecognizer`：用于处理缩放事件。

## 原始指针事件

在 Flutter 中，原始指针事件处理是指直接处理来自屏幕触摸或鼠标移动等输入设备的原始输入事件。这些事件在 Flutter 的事件模型中被称为“指针事件”（Pointer events）。

指针事件是最底层的输入事件，它们代表了用户与设备屏幕交互的原始数据。Flutter 提供了 `Listener` 小部件来监听和处理这些原始指针事件。`Listener` 小部件可以检测多种类型的指针事件，包括：

-   `PointerDownEvent`：当用户开始触摸屏幕时触发。
-   `PointerMoveEvent`：当用户在屏幕上移动触摸点时触发。
-   `PointerUpEvent`：当用户停止触摸屏幕时触发。
-   `PointerCancelEvent`：当触摸事件被取消时触发，例如由于系统手势或者电话来电等。

### 原始指针事件处理代码示例

下面是一个使用 `Listener` 小部件来处理原始指针事件的示例：

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Raw Pointer Events Example',
      home: Scaffold(
        appBar: AppBar(
          title: Text('Raw Pointer Events Example'),
        ),
        body: Center(
          child: MyPointerEventWidget(),
        ),
      ),
    );
  }
}

class MyPointerEventWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerDown: (PointerDownEvent event) {
        print('Pointer Down at: ${event.position}');
      },
      onPointerMove: (PointerMoveEvent event) {
        print('Pointer Moved to: ${event.position}');
      },
      onPointerUp: (PointerUpEvent event) {
        print('Pointer Up at: ${event.position}');
      },
      onPointerCancel: (PointerCancelEvent event) {
        print('Pointer Cancelled');
      },
      child: Container(
        width: 300,
        height: 300,
        color: Colors.blue,
        alignment: Alignment.center,
        child: Text('Touch Me', style: TextStyle(color: Colors.white)),
      ),
    );
  }
}
```

在这个示例中，我们创建了一个 `MyPointerEventWidget` 小部件，它使用 `Listener` 小部件来监听原始指针事件。当用户与屏幕交互时，我们打印出事件的类型和位置信息。这个小部件包含一个蓝色的容器，提示用户触摸它。

通过处理原始指针事件，开发者可以实现更复杂的交互逻辑，或者创建自定义的手势识别器。然而，对于大多数常见的交互场景，Flutter 提供了更高级别的手势识别器（如 `GestureDetector`），这些通常更易于使用。

## Flutter 事件机制是什么

Flutter 的事件机制主要基于两个层次的抽象：原始指针事件和手势识别。

1. **原始指针事件（Raw Pointer Events）**:
   这是最底层的事件，代表用户与设备屏幕的直接交互，如触摸、鼠标移动等。这些事件通过 `Listener` 小部件来处理。原始指针事件包括 `PointerDownEvent`、`PointerMoveEvent`、`PointerUpEvent` 和 `PointerCancelEvent` 等。

2. **手势识别（Gesture Recognition）**:
   在原始指针事件之上，Flutter 提供了一个手势识别框架，它可以将多个原始指针事件组合成特定的手势。例如，一系列的 `PointerDownEvent`、`PointerMoveEvent` 和 `PointerUpEvent` 可能会被识别为一个滑动手势。手势识别是通过 `GestureDetector` 小部件来实现的，它可以识别如点击（tap）、双击（double tap）、长按（long press）、拖动（drag）、缩放（pinch）等手势。

Flutter 的事件传递机制遵循以下路径：

-   当用户触摸屏幕时，Flutter 的底层系统会捕获触摸事件，并将其封装成原始指针事件。
-   原始指针事件首先被送到 Flutter 的渲染树中。如果有 `Listener` 小部件在事件发生的位置，它可以直接处理这些事件。
-   如果原始指针事件没有被 `Listener` 完全处理，它们会被送到手势识别器。手势识别器会根据事件序列尝试识别特定的手势。
-   如果手势被成功识别，相应的回调（如 onTap、onDoubleTap、onLongPress 等）会被调用。

Flutter 的事件机制允许开发者在不同层次上处理用户输入，可以选择直接处理原始指针事件，也可以利用手势识别器来处理更高级别的用户交互。这种设计提供了灵活性，使得开发者可以根据需要选择合适的抽象层次来构建用户界面。

## 手势原理与手势冲突

Flutter 的手势识别原理基于一个名为手势竞赛（gesture arena）的概念，它是一个用于解决手势冲突的机制。手势识别过程涉及以下几个关键组件：

1. **手势识别器（Gesture Recognizers）**:
   这些是一系列的类，如 `TapGestureRecognizer`、`LongPressGestureRecognizer`、`PanGestureRecognizer` 等，它们负责识别和解释原始指针事件序列为特定的手势。

2. **手势竞赛（Gesture Arena）**:
   当多个手势识别器监听同一组原始指针事件时，它们会加入到一个“竞技场”中。在这个竞技场中，识别器会根据收到的事件序列来声明自己可能赢得竞赛（即识别出手势）或者退出竞赛（即不再尝试识别手势）。

3. **胜出与失败**:
   当一个识别器确定它已经识别出一个手势时，它会在竞技场中宣布胜出。如果其他识别器还在竞赛中，它们会被告知失败，这时它们应该停止跟踪事件序列。胜出的识别器会获得后续事件的独占权，并触发相应的回调。

4. **手势冲突**:
   手势冲突发生在多个手势识别器同时尝试识别相同的原始指针事件序列时。例如，一个水平拖动和一个垂直拖动可能会同时尝试识别一个滑动手势。Flutter 的手势竞赛机制允许这些识别器“协商”哪一个应该胜出。

5. **解决手势冲突**:
   为了解决手势冲突，Flutter 允许开发者指定某些手势识别器的优先级，或者使用特定的小部件来解决冲突。例如，`GestureDetector` 小部件允许你指定哪些手势是有效的，而 `Listener` 小部件可以用来直接处理原始指针事件，绕过手势识别器。

6. **手势消歧**:
   在某些情况下，Flutter 提供了消歧策略，如 `DragStartBehavior`，它可以用来控制拖动手势的开始行为，以减少潜在的手势冲突。

通过这种机制，Flutter 能够处理复杂的手势交互，并允许多个手势识别器协同工作，同时确保用户界面的响应性和直观性。开发者可以通过合理的设计和对手势识别器的正确使用，来最小化或解决手势冲突问题。

## 事件总线

Flutter 中的事件总线通常是指一个用于跨组件通信的机制，它允许不同部分的应用程序相互发送消息。虽然 Flutter 没有内置的事件总线系统，但开发者可以自己实现一个，或者使用现有的库，如 `event_bus`。

```yaml
dependencies:
    flutter:
        sdk: flutter
    event_bus: ^2.0.0 # 确保使用最新版本
```

`EventBus` 是一个用于简化事件传递和组件间通信的工具，它通常是基于`Stream`和`StreamController`实现的。在 Flutter 中，你可以使用`EventBus`来实现跨组件或模块的事件通知和监听。

`StreamSubscription`与`EventBus`的关系在于，当你使用`EventBus`订阅一个事件时，你实际上是在监听一个`Stream`，而这个监听过程会返回一个`StreamSubscription`对象。你可以使用这个`StreamSubscription`对象来控制事件监听的生命周期，比如取消订阅。

event_bus 的源码：

```dart
class EventBus {
  StreamController _streamController;

  /// Controller for the event bus stream.
  StreamController get streamController => _streamController;

  /// Creates an [EventBus].
  ///
  /// If [sync] is true, events are passed directly to the stream's listeners
  /// during a [fire] call. If false (the default), the event will be passed to
  /// the listeners at a later time, after the code creating the event has
  /// completed.
  EventBus({bool sync = false})
      : _streamController = StreamController.broadcast(sync: sync);

  /// Instead of using the default [StreamController] you can use this constructor
  /// to pass your own controller.
  ///
  /// An example would be to use an RxDart Subject as the controller.
  EventBus.customController(StreamController controller)
      : _streamController = controller;

  /// Listens for events of Type [T] and its subtypes.
  ///
  /// The method is called like this: myEventBus.on<MyType>();
  ///
  /// If the method is called without a type parameter, the [Stream] contains every
  /// event of this [EventBus].
  ///
  /// The returned [Stream] is a broadcast stream so multiple subscriptions are
  /// allowed.
  ///
  /// Each listener is handled independently, and if they pause, only the pausing
  /// listener is affected. A paused listener will buffer events internally until
  /// unpaused or canceled. So it's usually better to just cancel and later
  /// subscribe again (avoids memory leak).
  ///
  Stream<T> on<T>() {
    if (T == dynamic) {
      return streamController.stream as Stream<T>;
    } else {
      return streamController.stream.where((event) => event is T).cast<T>();
    }
  }

  /// Fires a new event on the event bus with the specified [event].
  ///
  void fire(event) {
    streamController.add(event);
  }

  /// Destroy this [EventBus]. This is generally only in a testing context.
  ///
  void destroy() {
    _streamController.close();
  }
}
```

要使用第三方的`event_bus`库进行事件总线的通信，你可以按照以下步骤操作：

1. **添加依赖**：

    在你的`pubspec.yaml`文件中添加`event_bus`依赖：

    ```yaml
    dependencies:
        flutter:
            sdk: flutter
        event_bus: ^2.0.0 # 确保使用最新版本
    ```

    然后运行`flutter pub get`来安装依赖。

2. **创建 EventBus 实例**：

    创建一个全局的`EventBus`实例，以便在应用的不同部分之间共享。

    ```dart
    import 'package:event_bus/event_bus.dart';

    EventBus eventBus = EventBus();
    ```

    如果不好维护，可以通过静态变量维护一个全局的实例：

    ```dart
    import 'package:event_bus/event_bus.dart';

    class MyEventBus{
      static EventBus? _busInstance;

      static EventBus get busInstance{
        _busInstance?? = EventBus();
        return _busInstance;
      }
    }
    ```

3. **定义事件**：

    创建一个或多个事件类来传递数据。

    ```dart
    class UserLoggedInEvent {
      final String username;

      UserLoggedInEvent(this.username);
    }
    ```

4. **发送事件**：

    当你需要通知其他部分应用时，发布一个事件。

    ```dart
    eventBus.fire(UserLoggedInEvent('test'));
    ```

5. **监听事件**：

    在你想要响应事件的地方，监听特定类型的事件。

    ```dart
    // 在你的StatefulWidget的State类中，或者任何其他适当的地方
    StreamSubscription<UserLoggedInEvent> _loginSubscription;

    @override
    void initState() {
      super.initState();

      _loginSubscription = eventBus.on<UserLoggedInEvent>().listen((event) {
        print('User logged in: ${event.username}');
        // 这里可以执行任何响应事件的逻辑
      });
    }
    ```

6. **取消监听**：

    当你不再需要监听事件时，确保取消订阅以避免内存泄漏。

    ```dart
    @override
    void dispose() {
      _loginSubscription?.cancel();
      super.dispose();
    }
    ```

这就是如何在 Flutter 中使用第三方`event_bus`库来实现事件总线模式的基本步骤。通过这种方式，你可以在不同组件之间传递消息，而无需直接将它们连接起来。

## GestureDetector

`GestureDetector` 是 Flutter 中一个非常有用的小部件，它用于检测和响应用户的手势操作。通过它，你可以监听各种手势，如点击、双击、长按、拖动、滑动等。

`GestureDetector` 提供了一系列回调函数，用于处理不同的手势事件：

-   `onTap`：当用户轻触屏幕时触发。
-   `onDoubleTap`：当用户快速连续两次轻触屏幕时触发。
-   `onLongPress`：当用户在屏幕上按下并持续一段时间后触发。
-   `onPanUpdate`：当用户在屏幕上拖动时连续触发。
-   `onPanStart`：当用户开始拖动时触发。
-   `onPanEnd`：当用户停止拖动时触发。
-   `onHorizontalDragUpdate`：当用户水平拖动时连续触发。
-   `onVerticalDragUpdate`：当用户垂直拖动时连续触发。
-   等等。

## GestureDetector 代码示例

下面是一个简单的示例，展示了如何使用 `GestureDetector` 来监听单击、双击和长按事件：

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'GestureDetector Example',
      home: Scaffold(
        appBar: AppBar(
          title: Text('GestureDetector Example'),
        ),
        body: Center(
          child: MyGestureDetector(),
        ),
      ),
    );
  }
}

class MyGestureDetector extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Tap detected')),
        );
      },
      onDoubleTap: () {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Double tap detected')),
        );
      },
      onLongPress: () {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Long press detected')),
        );
      },
      child: Container(
        width: 200,
        height: 200,
        decoration: BoxDecoration(
          color: Colors.blue,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Center(
          child: Text(
            'Tap Me',
            style: TextStyle(
              color: Colors.white,
              fontSize: 24,
            ),
          ),
        ),
      ),
    );
  }
}
```

在这个示例中，我们创建了一个名为 `MyGestureDetector` 的无状态小部件，它包含一个 `GestureDetector`。`GestureDetector` 包裹了一个容器，该容器有一个蓝色背景和一个中心文本 "Tap Me"。我们为 `GestureDetector` 提供了三个回调：`onTap`、`onDoubleTap` 和 `onLongPress`。当用户与容器交互时，相应的回调会被触发，并显示一个 `SnackBar` 消息。

这个例子展示了 `GestureDetector` 的基本用法，你可以根据需要添加更多的手势处理回调。

### TapGestureRecognizer

`TapGestureRecognizer` 是 Flutter 中的一个手势识别器，它属于 `gestures` 库。与 `GestureDetector` 小部件不同，`TapGestureRecognizer` 是一个较低级别的 API，它可以直接与手势系统交互。使用 `TapGestureRecognizer` 可以在不使用 `GestureDetector` 小部件的情况下识别轻触手势。

`TapGestureRecognizer` 提供了几个回调，例如：

-   `onTapDown`：当用户触摸屏幕时触发。
-   `onTapUp`：当用户停止触摸屏幕时触发。
-   `onTap`：当发生轻触手势时触发。
-   `onTapCancel`：当触摸被取消或者更多的触摸点加入时触发。

### TapGestureRecognizer 代码示例

下面是一个使用 `TapGestureRecognizer` 的示例，它演示了如何在一个 `TextSpan` 上使用轻触手势识别器：

```dart
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'TapGestureRecognizer Example',
      home: Scaffold(
        appBar: AppBar(
          title: Text('TapGestureRecognizer Example'),
        ),
        body: Center(
          child: MyTapText(),
        ),
      ),
    );
  }
}

class MyTapText extends StatefulWidget {
  @override
  _MyTapTextState createState() => _MyTapTextState();
}

class _MyTapTextState extends State<MyTapText> {
  TapGestureRecognizer _tapGestureRecognizer;
  bool _isTapped = false;

  @override
  void initState() {
    super.initState();
    _tapGestureRecognizer = TapGestureRecognizer()
      ..onTap = _handleTap;
  }

  void _handleTap() {
    setState(() {
      _isTapped = !_isTapped;
    });
  }

  @override
  void dispose() {
    _tapGestureRecognizer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return RichText(
      text: TextSpan(
        text: 'Tap on ',
        style: TextStyle(color: Colors.black),
        children: <TextSpan>[
          TextSpan(
            text: 'this text!',
            style: TextStyle(
              color: _isTapped ? Colors.blue : Colors.red,
              decoration: TextDecoration.underline,
            ),
            recognizer: _tapGestureRecognizer,
          ),
        ],
      ),
    );
  }
}
```

在这个示例中，我们创建了一个名为 `MyTapText` 的有状态小部件，它包含一个 `RichText` 小部件，用于显示带有特殊样式的文本。我们使用 `TapGestureRecognizer` 来监听 "this text!" 部分的轻触事件。当用户轻触这段文本时，文本的颜色会在红色和蓝色之间切换。

注意，我们在 `initState` 方法中初始化了 `TapGestureRecognizer` 并设置了 `onTap` 回调。在 `dispose` 方法中，我们调用了 `_tapGestureRecognizer.dispose()` 来清理资源，这是防止内存泄漏的重要步骤。

这个例子展示了如何在不使用 `GestureDetector` 小部件的情况下，直接使用手势识别器来处理轻触手势。

### LongPressGestureRecognizer

`LongPressGestureRecognizer` 是 Flutter 中用于识别长按手势的一个类，它同样属于 `gestures` 库。当用户在同一个位置按下并持续一段时间后（通常是 500 毫秒），就会触发长按手势。

`LongPressGestureRecognizer` 提供了几个回调，例如：

-   `onLongPressStart`：当长按手势开始时触发。
-   `onLongPressMoveUpdate`：当长按手势位置发生变化时触发。
-   `onLongPressUp`：当用户抬起手指时触发。
-   `onLongPressEnd`：当长按手势结束时触发。
-   `onLongPress`：当长按手势识别完成时触发。

### LongPressGestureRecognizer 代码示例

下面是一个使用 `LongPressGestureRecognizer` 的示例，它演示了如何在一个 `Container` 上使用长按手势识别器：

```dart
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'LongPressGestureRecognizer Example',
      home: Scaffold(
        appBar: AppBar(
          title: Text('LongPressGestureRecognizer Example'),
        ),
        body: Center(
          child: MyLongPressBox(),
        ),
      ),
    );
  }
}

class MyLongPressBox extends StatefulWidget {
  @override
  _MyLongPressBoxState createState() => _MyLongPressBoxState();
}

class _MyLongPressBoxState extends State<MyLongPressBox> {
  Color _boxColor = Colors.blue;

  LongPressGestureRecognizer _longPressGestureRecognizer;

  @override
  void initState() {
    super.initState();
    _longPressGestureRecognizer = LongPressGestureRecognizer()
      ..onLongPress = _handleLongPress;
  }

  void _handleLongPress() {
    setState(() {
      _boxColor = _boxColor == Colors.blue ? Colors.green : Colors.blue;
    });
  }

  @override
  void dispose() {
    _longPressGestureRecognizer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onLongPress: _handleLongPress,
      child: Container(
        width: 200,
        height: 200,
        color: _boxColor,
        alignment: Alignment.center,
        child: Text(
          'Long Press Me',
          style: TextStyle(color: Colors.white, fontSize: 24),
        ),
      ),
    );
  }
}
```

在这个示例中，我们创建了一个名为 `MyLongPressBox` 的有状态小部件，它包含一个 `Container` 小部件，用于显示一个可长按的方块。我们使用 `LongPressGestureRecognizer` 来监听长按事件。当用户在方块上长按时，方块的颜色会在蓝色和绿色之间切换。

注意，我们在 `initState` 方法中初始化了 `LongPressGestureRecognizer` 并设置了 `onLongPress` 回调。在 `dispose` 方法中，我们调用了 `_longPressGestureRecognizer.dispose()` 来清理资源，这是防止内存泄漏的重要步骤。

这个例子展示了如何在不使用 `GestureDetector` 小部件的情况下，直接使用手势识别器来处理长按手势。然而，在这个例子中，我们实际上并没有使用 `_longPressGestureRecognizer`，而是直接在 `GestureDetector` 中使用了 `onLongPress` 回调。这是因为在大多数情况下，使用 `GestureDetector` 小部件会更简单、更方便。如果你需要更细粒度的控制，或者需要同时识别多种手势，那么直接使用手势识别器类可能会更合适。

### ScaleGestureRecognizer

`ScaleGestureRecognizer` 是 Flutter 中用于识别缩放手势的一个类，它属于 `gestures` 库。缩放手势通常是由两个触摸点在屏幕上进行对开或者闭合的动作来实现的，这在用户界面中常用于缩放图片或者地图。

`ScaleGestureRecognizer` 提供了几个回调，例如：

-   `onStart`：当缩放手势开始时触发。
-   `onUpdate`：当缩放手势更新时触发，例如手指移动时。
-   `onEnd`：当缩放手势结束时触发。

### ScaleGestureRecognizer 代码示例

下面是一个使用 `ScaleGestureRecognizer` 的示例，它演示了如何在一个图片上使用缩放手势识别器：

```dart
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ScaleGestureRecognizer Example',
      home: Scaffold(
        appBar: AppBar(
          title: Text('ScaleGestureRecognizer Example'),
        ),
        body: Center(
          child: MyScalingImage(),
        ),
      ),
    );
  }
}

class MyScalingImage extends StatefulWidget {
  @override
  _MyScalingImageState createState() => _MyScalingImageState();
}

class _MyScalingImageState extends State<MyScalingImage> {
  double _scale = 1.0;
  double _baseScale = 1.0;

  // Create a ScaleGestureRecognizer.
  ScaleGestureRecognizer _scaleGestureRecognizer = ScaleGestureRecognizer();

  @override
  void dispose() {
    // Clean up the controller when the widget is disposed.
    _scaleGestureRecognizer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      // Set onScaleStart, onScaleUpdate, onScaleEnd callbacks
      onScaleStart: (ScaleStartDetails details) {
        _baseScale = _scale;
      },
      onScaleUpdate: (ScaleUpdateDetails details) {
        setState(() {
          _scale = _baseScale * details.scale;
        });
      },
      onScaleEnd: (ScaleEndDetails details) {
        _baseScale = 1.0;
      },
      child: Transform.scale(
        scale: _scale,
        child: Container(
          width: 200,
          height: 200,
          decoration: BoxDecoration(
            image: DecorationImage(
              image: NetworkImage('https://placekitten.com/200/200'),
              fit: BoxFit.cover,
            ),
          ),
        ),
      ),
    );
  }
}
```

在这个示例中，我们创建了一个名为 `MyScalingImage` 的有状态小部件，它包含一个 `Container` 小部件，用于显示一个可缩放的图片。我们使用 `GestureDetector` 来监听缩放事件，并通过 `Transform.scale` 小部件来应用缩放效果。

当用户开始缩放手势时，我们记录当前的缩放比例 `_baseScale`。随着用户的缩放动作，我们更新 `_scale` 的值，并在 `setState` 调用中更新 UI。当缩放手势结束时，我们重置 `_baseScale`。

请注意，虽然我们创建了一个 `ScaleGestureRecognizer` 实例 `_scaleGestureRecognizer`，但在这个例子中我们并没有直接使用它。这是因为 `GestureDetector` 小部件已经为我们提供了处理缩放手势的便捷方式。如果你需要更细粒度的控制，或者需要同时识别多种手势，那么直接使用手势识别器类可能会更合适。在这种情况下，你需要手动创建 `ScaleGestureRecognizer` 的实例，并在小部件树中适当的位置调用它的回调。
