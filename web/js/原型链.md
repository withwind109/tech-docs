## 为什么会有原型链

JS 不是一门完全面向对象编程的语言，所以如何涉及继承机制，就是一个问题。

ES6 中的 `class` 语法并不引入一种全新的面向对象继承模型，它提供的是基于现有原型继承的语法糖。在 JavaScript 中，类（class）实质上仍然是通过函数来实现的。

原型链的设计主要是为了解决对象间的继承问题，即如何让一个对象能够访问到另一个对象的属性和方法。在没有类的概念之前，JavaScript 需要一种机制来实现继承，原型链就是这样一种机制。

举个例子，假设我们有一个构造函数 `Animal`，它有一个方法 `speak`。我们想要创建一个 `Dog` 构造函数，让所有的 `Dog` 实例都能够使用 `Animal` 的 `speak` 方法，而不需要在每个 `Dog` 实例中都复制这个方法。

```javascript
// 声明Animal
function Animal(name) {
    this.name = name;
}

// 创建speak方法
Animal.prototype.speak = function () {
    console.log(this.name + ' makes a noise.');
};

function Dog(name) {
    Animal.call(this, name); // 调用 Animal 的构造函数
}

// 设置 Dog 的原型为 Animal 的实例，建立原型链
Dog.prototype = Object.create(Animal.prototype);
// 修正 Dog.prototype 的构造函数指向
Dog.prototype.constructor = Dog;

// 可以为 Dog 实例添加特有的方法
Dog.prototype.bark = function () {
    console.log(this.name + ' barks.');
};

var dog = new Dog('Rex');
dog.speak(); // Rex makes a noise.
dog.bark(); // Rex barks.
```

在这个例子中，`Dog` 的原型被设置为 `Animal` 的一个实例，这样 `Dog` 的所有实例都可以通过原型链访问到 `Animal` 原型上定义的 `speak` 方法。这就是原型链解决的问题：允许对象继承另一个对象的属性和方法，实现代码复用和内存效率。

如果没有原型链，我们就需要在每个 `Dog` 实例中单独实现 `speak` 方法，这会导致代码重复和不必要的内存使用。原型链通过原型对象共享方法，避免了这些问题。

总结：

1. **代码复用**：通过原型链，对象可以继承另一个对象的属性和方法，这样就可以复用代码，而不需要在每个对象中重新定义相同的方法。

2. **内存效率**：由于继承的属性和方法定义在原型对象上，所有继承自该原型的对象都可以访问这些属性和方法，而不需要在每个对象实例中都创建一份。这样可以节省内存，因为共享的部分只存储一次。

3. **动态修改**：由于对象通过原型链查找属性和方法，如果修改了原型上的属性或方法，所有继承自该原型的对象都会受到影响。这提供了一种动态更新多个对象行为的方式。

## **proto**

`__proto__` 是一个非标准但广泛支持的属性，它用于访问一个对象的内部原型（即内部 `[[Prototype]]` 属性）。在 JavaScript 中，几乎所有的对象都有一个原型，对象从其原型继承属性和方法。

当你尝试访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或到达原型链的末端（通常是 `Object.prototype`，它的原型是 `null`）。

这里是一个简单的例子：

```javascript
let animal = {
    eats: true,
};

let rabbit = {
    jumps: true,
};

rabbit.__proto__ = animal; // 设置 rabbit 的原型为 animal

console.log(rabbit.eats); // true，因为它是从原型继承来的
```

在这个例子中，`rabbit` 对象的 `__proto__` 属性被设置为 `animal` 对象，这意味着 `rabbit` 现在继承了 `animal` 的属性。

然而，需要注意的是 `__proto__` 并不是标准属性，它最初是由某些浏览器实现的，后来被其他浏览器广泛采用。尽管它在大多数现代浏览器中都可用，但它并不是 ECMAScript 规范的一部分，直到 ES6 将其作为遗留特性正式包含在规范中。即便如此，使用 `__proto__` 仍然不被推荐，因为它可能在未来的 JavaScript 版本中被废弃。

为了在现代代码中操作对象的原型，推荐使用 `Object.getPrototypeOf()` 和 `Object.setPrototypeOf()` 方法，或者使用 `Object.create()` 来创建一个新对象，其原型指向另一个对象。
